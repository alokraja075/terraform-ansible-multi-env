# Terraform + Ansible Multi-Environment Setup

This repository contains an Infrastructure as Code (IaC) solution for managing EC2 instances across multiple environments (test, staging, production) using Terraform and Ansible.

## Architecture Overview

```
┌─────────────────────────────────────────────────────────┐
│                   Terraform (IaC)                       │
│  ┌──────────────────────────────────────────────────┐  │
│  │  Create & Manage EC2 Infrastructure             │  │
│  │  - EC2 Instances                                │  │
│  │  - Security Groups                              │  │
│  │  - SSH Key Pairs                                │  │
│  │  - VPC Configuration                            │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
                        │
                        │ Outputs: Instance DNS/IP
                        ▼
┌─────────────────────────────────────────────────────────┐
│                  Ansible (Configuration)                │
│  ┌──────────────────────────────────────────────────┐  │
│  │  Configure & Manage Running Instances           │  │
│  │  - System Updates                               │  │
│  │  - Install Nginx                                │  │
│  │  - Deploy Custom Configurations                 │  │
│  │  - Service Management                           │  │
│  └──────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────┘
```

## Directory Structure

```
terraform-ansible-multi-env/
├── main.tf                          # Root module configuration
├── provider.tf                      # AWS provider setup
├── variable.tf                      # Root variables
├── output.tf                        # Root outputs
├── terraform.tfvars                 # Default values
├── terraform.test.tfvars            # Test environment
├── terraform.prod.tfvars            # Production environment
├── backend.tf                       # Terraform backend config
│
├── modules/
│   └── ec2/                         # EC2 module
│       ├── main.tf
│       ├── variables.tf
│       └── outputs.tf
│
├── ansible/                         # Ansible configuration
│   ├── playbook.yml                # Main playbook
│   ├── ansible.cfg                 # Ansible config
│   ├── generate-inventory.sh       # Generate inventory from TF
│   ├── run-playbook.sh             # Run playbook script
│   ├── README.md                    # Ansible documentation
│   │
│   ├── roles/
│   │   ├── system-update/          # Update system packages
│   │   │   └── tasks/
│   │   │       └── main.yml
│   │   └── nginx/                  # Install & configure Nginx
│   │       ├── tasks/
│   │       │   └── main.yml
│   │       ├── handlers/
│   │       │   └── main.yml
│   │       └── templates/
│   │           ├── nginx.conf.j2
│   │           └── index.html.j2
│   │
│   └── inventory/
│       └── hosts.ini               # Ansible inventory (auto-generated)
│
├── key/                            # SSH keys (generated by Terraform)
│   ├── MyEC2Key
│   └── MyEC2Key.pub
│
├── install_server.sh               # Legacy user-data script (optional)
├── README.md                        # This file
└── terraform.tfstate.d/            # Terraform state directory
    ├── main/
    └── test/
```

## Quick Start

### Prerequisites

1. **AWS Account** with appropriate credentials
2. **Terraform** installed (v1.0+)
3. **Ansible** installed (v2.10+)
4. **SSH** client configured
5. **Git** (optional, for version control)

### Setup

1. **Clone the repository:**
   ```bash
   git clone <repository-url>
   cd terraform-ansible-multi-env
   ```

2. **Configure AWS credentials:**
   ```bash
   aws configure
   ```

3. **Install Ansible:**
   ```bash
   pip install ansible
   ```

### Deployment Workflow

#### Step 1: Deploy Infrastructure with Terraform

1. **Plan the deployment:**
   ```bash
   # For test environment
   terraform plan -var-file="terraform.test.tfvars"
   
   # For production environment
   terraform plan -var-file="terraform.prod.tfvars"
   ```

2. **Apply the configuration:**
   ```bash
   # For test environment
   terraform apply -var-file="terraform.test.tfvars" -auto-approve
   
   # For production environment
   terraform apply -var-file="terraform.prod.tfvars" -auto-approve
   ```

3. **View outputs:**
   ```bash
   terraform output
   ```

#### Step 2: Configure Instances with Ansible

1. **Generate inventory from Terraform outputs:**
   ```bash
   cd ansible
   bash generate-inventory.sh
   ```

2. **Run the Ansible playbook:**
   ```bash
   bash run-playbook.sh
   ```

Or manually:
```bash
ansible-playbook -i inventory/hosts.ini playbook.yml
```

### Full Deployment Example

```bash
# 1. Deploy test infrastructure
terraform plan -var-file="terraform.test.tfvars"
terraform apply -var-file="terraform.test.tfvars" -auto-approve

# 2. Configure test instances
cd ansible
bash generate-inventory.sh
bash run-playbook.sh
cd ..

# 3. Wait a moment for Nginx to be accessible
sleep 10

# 4. Test the deployment
TEST_IP=$(terraform output -raw instance_public_dns)
curl http://$TEST_IP
```

## Environment-Specific Configuration

### Test Environment (`terraform.test.tfvars`)
- Instance Type: `t3.micro` (free tier eligible)
- EBS Volume: 10GB
- Public IP: Yes
- Monitoring: Off
- SSH Access: Unrestricted (0.0.0.0/0)

### Production Environment (`terraform.prod.tfvars`)
- Instance Type: `t3.small` (better performance)
- EBS Volume: 50GB
- Public IP: No (uses private networking)
- Monitoring: On (CloudWatch)
- SSH Access: Private network only (10.0.0.0/8)

## Terraform Modules

### EC2 Module (`modules/ec2/`)

Manages EC2 instance lifecycle:

**Inputs:**
- `key_pair_name`: SSH key pair name (required)
- `instance_type`: EC2 instance type (required)
- `security_group_name`: Name of security group (required)
- `ingress_rules`: Inbound traffic rules (required)
- `egress_rules`: Outbound traffic rules (required)
- `instance_name`: Instance name tag (required)
- `ebs_block_devices`: Additional volumes (optional)
- `tags`: Resource tags (optional)

**Outputs:**
- `instance_id`: EC2 instance ID
- `instance_public_ip`: Public IP address
- `instance_public_dns`: Public DNS name
- `security_group_id`: Security group ID
- `key_pair_name`: SSH key pair name
- `ssh_command`: SSH connection command
- `ssh_key_path`: Path to private SSH key

## Ansible Roles

### system-update Role

Updates system packages and installs essential tools.

**Tasks:**
- Update apt cache
- Upgrade packages
- Install utilities (curl, unzip, wget, git, vim)
- Clean up unused packages

**Usage:**
```bash
ansible-playbook playbook.yml --tags system-update
```

### nginx Role

Installs, configures, and manages Nginx web server.

**Tasks:**
- Install Nginx package
- Deploy Nginx configuration
- Create web directory structure
- Deploy custom index.html
- Enable and start Nginx service
- Verify service status

**Customizations:**
- Edit `roles/nginx/templates/nginx.conf.j2` for Nginx settings
- Edit `roles/nginx/templates/index.html.j2` for homepage

**Usage:**
```bash
ansible-playbook playbook.yml --tags nginx
```

## Common Tasks

### Update a Single Instance

```bash
cd ansible
ansible-playbook -i inventory/hosts.ini playbook.yml --limit "ec2-instance-1"
```

### Run Only System Updates

```bash
cd ansible
ansible-playbook -i inventory/hosts.ini playbook.yml --tags system-update
```

### Run Only Nginx Configuration

```bash
cd ansible
ansible-playbook -i inventory/hosts.ini playbook.yml --tags nginx
```

### SSH into EC2 Instance

```bash
# Method 1: Using SSH command from Terraform output
eval $(terraform output SSH_Key_Command)

# Method 2: Manual SSH
ssh -i key/MyEC2Key ubuntu@<instance-dns>
```

### Destroy Infrastructure

```bash
# Test environment
terraform destroy -var-file="terraform.test.tfvars" -auto-approve

# Production environment
terraform destroy -var-file="terraform.prod.tfvars" -auto-approve
```

## Troubleshooting

### Terraform Issues

**Error: "Terraform state directory not found"**
```bash
# Initialize Terraform workspace
terraform init
terraform workspace select test  # or 'main' for default
```

**Error: "AWS credentials not found"**
```bash
aws configure  # Configure AWS CLI with your credentials
```

### Ansible Issues

**Error: "Host not reachable"**
```bash
# Test SSH connectivity
ssh -i key/MyEC2Key ubuntu@<instance-dns>

# Check security group allows SSH (port 22)
aws ec2 describe-security-groups --group-id <sg-id>
```

**Error: "Permission denied (publickey)"**
```bash
# Check key permissions
chmod 400 key/MyEC2Key

# Check if using correct key
# Verify key_pair_name in terraform.tfvars
```

**Error: "Inventory file not found"**
```bash
cd ansible
bash generate-inventory.sh  # Regenerate inventory
```

### Service Issues

**Nginx not starting**
```bash
# SSH into instance
ssh -i key/MyEC2Key ubuntu@<instance-dns>

# Check Nginx status
systemctl status nginx

# Check for configuration errors
sudo nginx -t
```

## Best Practices

### Security

1. **SSH Keys:** Keep private keys secure
   ```bash
   chmod 400 key/*
   ```

2. **Security Groups:** Restrict access appropriately
   - Production: Limit SSH to specific IPs
   - Test: Can be more permissive

3. **State Management:** Protect Terraform state
   ```bash
   # Use remote state (S3 backend)
   # Enable state locking
   # Encrypt sensitive data
   ```

### Infrastructure Management

1. **Use Workspaces:** Separate test and production states
   ```bash
   terraform workspace new prod
   terraform workspace select prod
   ```

2. **Plan Before Apply:** Always review changes
   ```bash
   terraform plan -var-file="terraform.prod.tfvars" > plan.txt
   # Review plan.txt
   terraform apply plan.txt
   ```

3. **Tag Resources:** For better organization
   ```hcl
   tags = {
     Environment = "production"
     Project     = "terraform-ansible"
     CostCenter  = "ops"
   }
   ```

### Ansible Best Practices

1. **Idempotent Playbooks:** Ensure roles are idempotent
2. **Use Roles:** Organize playbooks with roles
3. **Error Handling:** Implement proper error handling
4. **Documentation:** Document role variables and tasks

## Advanced Topics

### Multiple EC2 Instances

Create multiple instances by calling the module multiple times:

```hcl
module "web_server_1" {
  source = "./modules/ec2"
  # ... configuration
  instance_name = "web-server-1"
}

module "web_server_2" {
  source = "./modules/ec2"
  # ... configuration
  instance_name = "web-server-2"
}
```

### Custom Ansible Roles

Add new roles:

```bash
cd ansible
ansible-galaxy init roles/my-role
```

Then include in `playbook.yml`.

### Integration with CI/CD

Use GitHub Actions or GitLab CI:

```yaml
# .github/workflows/deploy.yml
name: Deploy Infrastructure
on: [push]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - name: Terraform Apply
        run: terraform apply -auto-approve
      - name: Run Ansible
        run: cd ansible && bash run-playbook.sh
```

## Resources

- [Terraform Documentation](https://www.terraform.io/docs/)
- [Ansible Documentation](https://docs.ansible.com/)
- [AWS EC2 Documentation](https://docs.aws.amazon.com/ec2/)
- [Terraform AWS Provider](https://registry.terraform.io/providers/hashicorp/aws/latest)

## Support & Contributions

For issues or contributions, please refer to the repository's contribution guidelines.

## License

See LICENSE file for details.

---

**Last Updated:** December 29, 2025
**Version:** 1.0
